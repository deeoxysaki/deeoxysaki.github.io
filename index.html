<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eclipse V4.1 - Deep Structural Lua Scanner</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Lucide Icons (Vanilla) -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Custom Font Styles -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Rajdhani:wght@500;600;700&display=swap');
        
        .font-tech { font-family: 'Rajdhani', sans-serif; }
        .font-mono { font-family: 'JetBrains Mono', monospace; }
        
        .custom-scrollbar::-webkit-scrollbar { width: 8px; height: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #050505; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #444; }

        .scan-line {
            position: absolute;
            width: 100%;
            height: 2px;
            background: rgba(168, 85, 247, 0.8);
            box-shadow: 0 0 10px #a855f7;
            animation: scan-down 2s linear infinite;
        }

        @keyframes scan-down {
            0% { top: 0%; opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { top: 100%; opacity: 0; }
        }

        .animate-fade-in { animation: fadeIn 0.4s ease-out; }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body class="bg-black text-white overflow-hidden">
    <div id="root"></div>

    <script type="text/babel">
        // --- Setup Dependencies ---
        const { useState, useRef, useEffect, useMemo, useCallback } = React;

        // --- Icon Components ---
        const LucideIcon = ({ name, size = 24, className, ...props }) => {
            const iconData = lucide.icons[name];
            if (!iconData) return null;
            return (
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width={size}
                    height={size}
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    strokeWidth="2"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    className={className}
                    {...props}
                >
                    {iconData.map((child, index) => {
                        const [tag, attrs] = child;
                        return React.createElement(tag, { ...attrs, key: index });
                    })}
                </svg>
            );
        };

        const Icons = {
            Shield: (p) => <LucideIcon name="Shield" {...p} />,
            LayoutDashboard: (p) => <LucideIcon name="LayoutDashboard" {...p} />,
            Scan: (p) => <LucideIcon name="Scan" {...p} />,
            Activity: (p) => <LucideIcon name="Activity" {...p} />,
            FileCode: (p) => <LucideIcon name="FileCode" {...p} />,
            AlertTriangle: (p) => <LucideIcon name="AlertTriangle" {...p} />,
            ArrowRight: (p) => <LucideIcon name="ArrowRight" {...p} />,
            X: (p) => <LucideIcon name="X" {...p} />,
            Trash2: (p) => <LucideIcon name="Trash2" {...p} />,
            Code: (p) => <LucideIcon name="Code" {...p} />,
            Terminal: (p) => <LucideIcon name="Terminal" {...p} />,
            Database: (p) => <LucideIcon name="Database" {...p} />,
            CheckCircle: (p) => <LucideIcon name="CheckCircle" {...p} />,
            Minimize2: (p) => <LucideIcon name="Minimize2" {...p} />,
            Maximize2: (p) => <LucideIcon name="Maximize2" {...p} />,
            Zap: (p) => <LucideIcon name="Zap" {...p} />,
            Fingerprint: (p) => <LucideIcon name="Fingerprint" {...p} />
        };

        // --- DEEP ANALYSIS ENGINE ---

        const KEYWORDS = new Set([
            'and', 'break', 'do', 'else', 'elseif', 'end', 'false', 'for', 'function', 'if',
            'in', 'local', 'nil', 'not', 'or', 'repeat', 'return', 'then', 'true', 'until', 'while'
        ]);

        const GLOBALS = new Set([
            'print', 'math', 'table', 'string', 'pairs', 'ipairs', 'next', 'select', 'pcall', 'xpcall',
            'type', 'tostring', 'tonumber', 'error', 'assert', 'setmetatable', 'getmetatable', 'rawset', 'rawget',
            'game', 'workspace', 'script', 'wait', 'spawn', 'delay', 'tick', 'task', 'warn', 'require'
        ]);

        const TokenType = {
            KEYWORD: 'KEYWORD',
            GLOBAL: 'GLOBAL',
            IDENTIFIER: 'ID',
            STRING: 'STRING',
            NUMBER: 'NUMBER',
            OPERATOR: 'OP',
            NEWLINE: 'NEWLINE',
            UNKNOWN: 'UNKNOWN'
        };

        // Improved Tokenizer that handles newlines for line-matching
        const tokenize = (code) => {
            const tokens = [];
            // We do NOT strip everything initially, we handle comments as skippable tokens
            
            const patterns = [
                { type: null, regex: /--\[\[[\s\S]*?\]\]/y }, // Block comment (skip)
                { type: null, regex: /--.*/y }, // Line comment (skip)
                { type: TokenType.STRING, regex: /"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*'/y },
                { type: TokenType.STRING, regex: /\[(=*)\[[\s\S]*?\]\1\]/y }, // Long strings
                { type: TokenType.NUMBER, regex: /0x[0-9a-fA-F]+|\d+(\.\d+)?([eE][+-]?\d+)?/y },
                { type: TokenType.OPERATOR, regex: /(\.\.\.|==|~=|<=|>=|\.\.|[\+\-\*\/%\^#=<>;:,\.\(\)\[\]\{\}])/y },
                { type: TokenType.IDENTIFIER, regex: /[a-zA-Z_][a-zA-Z0-9_]*/y },
                { type: TokenType.NEWLINE, regex: /\n/y },
                { type: null, regex: /\s+/y } // Skip other whitespace
            ];

            let cursor = 0;
            const length = code.length;
            while (cursor < length) {
                let match = null;
                for (let { type, regex } of patterns) {
                    regex.lastIndex = cursor;
                    match = regex.exec(code);
                    if (match) {
                        if (type) {
                            let value = match[0];
                            let finalType = type;

                            if (type === TokenType.IDENTIFIER) {
                                if (KEYWORDS.has(value)) finalType = TokenType.KEYWORD;
                                else if (GLOBALS.has(value)) finalType = TokenType.GLOBAL;
                            }

                            tokens.push({
                                type: finalType,
                                value: value,
                                index: cursor
                            });
                        }
                        cursor = regex.lastIndex;
                        break;
                    }
                }
                if (!match) {
                    cursor++;
                }
            }
            return tokens;
        };

        const getAbstractValue = (token) => {
            if (token.type === TokenType.IDENTIFIER) return '__VAR__';
            if (token.type === TokenType.NEWLINE) return '__NL__';
            return token.value; 
        };

        const performDeepAnalysis = (tokens1, tokens2) => {
            // Filter out newlines for the Sliding Window check (tokens1_clean)
            // But keep them for Line Structural check
            const cleanT1 = tokens1.filter(t => t.type !== TokenType.NEWLINE);
            const cleanT2 = tokens2.filter(t => t.type !== TokenType.NEWLINE);

            // --- STRATEGY 1: LINE-BY-LINE STRUCTURAL MATCH ---
            // "Grab a piece of code from the line... scan if there is a code piece... appearance to that"
            
            const matchedIndices1 = new Set();
            const matchedIndices2 = new Set();
            const renamedVars = new Set();

            // Helper to break tokens into lines based on NEWLINE token
            const getLines = (tokens) => {
                const lines = [];
                let currentLine = [];
                tokens.forEach(t => {
                    if (t.type === TokenType.NEWLINE) {
                        if (currentLine.length > 0) lines.push(currentLine);
                        currentLine = [];
                    } else {
                        currentLine.push(t);
                    }
                });
                if (currentLine.length > 0) lines.push(currentLine);
                return lines;
            };

            const lines1 = getLines(tokens1);
            const lines2 = getLines(tokens2);

            // Create signatures for every line in Original
            // Signature = abstract values joined
            const lineSignatures = new Map(); // Sig -> [TokenIndices]

            lines1.forEach((lineTokens) => {
                if (lineTokens.length < 3) return; // Skip very short lines
                const sig = lineTokens.map(getAbstractValue).join('|');
                // Store the indices of tokens in this line
                const indices = lineTokens.map(t => tokens1.indexOf(t)); // Note: Using indexOf on object ref is slow, better to use stored index if we had ID. 
                // Optimization: tokens objects are refs.
                // Actually, let's map signature to the abstract signature itself for fast lookup
                lineSignatures.set(sig, true); 
            });

            // Scan Suspect Lines against Signatures
            lines2.forEach((lineTokens) => {
                if (lineTokens.length < 3) return;
                const sig = lineTokens.map(getAbstractValue).join('|');
                
                if (lineSignatures.has(sig)) {
                    // Line Match Found!
                    lineTokens.forEach(t => {
                        const idx = tokens2.indexOf(t);
                        if (idx !== -1) matchedIndices2.add(idx);
                    });
                    
                    // We need to find *which* line in original matched to highlight it (heuristic: first match)
                    // Re-scan lines1 to find matching sig (inefficient but accurate for visual)
                    for (let l1 of lines1) {
                         const s1 = l1.map(getAbstractValue).join('|');
                         if (s1 === sig) {
                             l1.forEach(t => {
                                 const idx = tokens1.indexOf(t);
                                 if (idx !== -1) matchedIndices1.add(idx);
                             });
                             
                             // Detect renames on this line
                             for(let k=0; k<l1.length && k<lineTokens.length; k++) {
                                 if (l1[k].type === TokenType.IDENTIFIER && lineTokens[k].type === TokenType.IDENTIFIER) {
                                     if (l1[k].value !== lineTokens[k].value) {
                                         renamedVars.add(`${l1[k].value} -> ${lineTokens[k].value}`);
                                     }
                                 }
                             }
                             break; // Highlight first occurrence only
                         }
                    }
                }
            });

            // --- STRATEGY 2: SLIDING WINDOW (Fallback for obfuscated formatting) ---
            const WINDOW_SIZE = 8;
            const fingerprintMap = new Map();

            for (let i = 0; i <= cleanT1.length - WINDOW_SIZE; i++) {
                const window = cleanT1.slice(i, i + WINDOW_SIZE);
                const signature = window.map(getAbstractValue).join('|');
                if (!fingerprintMap.has(signature)) fingerprintMap.set(signature, []);
                fingerprintMap.get(signature).push(i);
            }

            for (let i = 0; i <= cleanT2.length - WINDOW_SIZE; i++) {
                const window = cleanT2.slice(i, i + WINDOW_SIZE);
                const signature = window.map(getAbstractValue).join('|');

                if (fingerprintMap.has(signature)) {
                    const originalStarts = fingerprintMap.get(signature);
                    
                    // Mark match in Suspect (Clean indices map back to real tokens?? No, cleanT2 are subsets)
                    // We need to mark the actual tokens.
                    window.forEach(t => {
                        const idx = tokens2.indexOf(t);
                        if(idx !== -1) matchedIndices2.add(idx);
                    });

                    originalStarts.forEach(startIdx => {
                         const origWindow = cleanT1.slice(startIdx, startIdx + WINDOW_SIZE);
                         origWindow.forEach(t => {
                             const idx = tokens1.indexOf(t);
                             if(idx !== -1) matchedIndices1.add(idx);
                         });
                    });
                }
            }

            const score = tokens2.length > 0 ? (matchedIndices2.size / tokens2.length) * 100 : 0;

            return {
                score: score.toFixed(1),
                matchedIndices1,
                matchedIndices2,
                renamedVars: Array.from(renamedVars).slice(0, 10),
                totalTokens: tokens2.length,
                matchedTokenCount: matchedIndices2.size
            };
        };


        // --- COMPONENTS ---

        // Memoized CodeViewer to prevent re-renders of massive DOM
        const CodeViewer = React.memo(({ title, tokens, matchedIndices, colorTheme = "red", isPreview = false }) => {
            // Optimization: If isPreview is true, only render first X tokens to prevent lag during animation
            const displayTokens = isPreview ? tokens.slice(0, 1000) : tokens;
            const truncated = isPreview && tokens.length > 1000;

            return (
                <div className="flex flex-col h-full bg-[#0a0a0a] border border-gray-800 rounded-lg overflow-hidden shadow-2xl">
                    <div className="bg-[#111] px-4 py-3 border-b border-gray-800 flex justify-between items-center bg-gradient-to-r from-gray-900 to-black">
                        <span className={`font-mono text-xs font-bold uppercase tracking-wider flex items-center gap-2 ${colorTheme === 'red' ? 'text-red-400' : 'text-cyan-400'}`}>
                            <Icons.Code className="w-4 h-4" /> {title}
                        </span>
                        <span className="text-[10px] font-mono text-gray-500 bg-gray-900 px-2 py-1 rounded-full border border-gray-800">
                            {tokens.length} TOKENS
                        </span>
                    </div>
                    <div className="flex-1 overflow-auto p-4 font-mono text-xs md:text-sm custom-scrollbar bg-black/50 backdrop-blur-sm">
                        <div className="leading-6 break-words whitespace-pre-wrap">
                            {displayTokens.map((token, i) => {
                                // Skip newlines in visual rendering if we just want line breaks
                                if (token.type === TokenType.NEWLINE) return <br key={i}/>;

                                // We need the original index to check matches properly
                                // Since we sliced, i corresponds to displayTokens index.
                                // But matchedIndices stores indices relative to FULL token array.
                                // We need to find the token's real index? 
                                // Actually, token objects are unique refs in our flow if we don't regenerate them.
                                // But matchedIndices stores integers.
                                // If we just use 'i' here, it works because displayTokens is a slice from 0.
                                const isMatched = matchedIndices.has(i);
                                
                                let className = "inline-block px-[1px] rounded-sm transition-all duration-300 ";
                                
                                if (isMatched) {
                                    className += colorTheme === "red" 
                                        ? "bg-red-900/60 text-white shadow-[0_0_8px_rgba(220,38,38,0.4)] font-bold border-b border-red-500 "
                                        : "bg-cyan-900/60 text-white shadow-[0_0_8px_rgba(8,145,178,0.4)] font-bold border-b border-cyan-500 ";
                                } else {
                                    if (token.type === TokenType.KEYWORD) className += "text-purple-400";
                                    else if (token.type === TokenType.GLOBAL) className += "text-yellow-300";
                                    else if (token.type === TokenType.STRING) className += "text-green-400";
                                    else if (token.type === TokenType.NUMBER) className += "text-blue-400";
                                    else if (token.type === TokenType.OPERATOR) className += "text-gray-500";
                                    else className += "text-gray-400";
                                }

                                const space = (token.type === TokenType.OPERATOR || token.value === ',') ? "" : " ";
                                const isBlockEnd = token.value === 'end' || token.value === 'then' || token.value === 'do' || token.value === ';';

                                return (
                                    <React.Fragment key={i}>
                                        <span className={className} title={token.type}>{token.value}</span>
                                        {space}
                                        {isBlockEnd && <br/>}
                                    </React.Fragment>
                                );
                            })}
                            {truncated && (
                                <div className="mt-4 text-gray-500 italic text-center border-t border-gray-800 pt-2">
                                    ... PREVIEW TRUNCATED FOR PERFORMANCE ...
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        });

        const DashboardView = ({ scanHistory, clearHistory }) => (
            <div className="space-y-6 animate-fade-in p-2 font-tech">
                <div className="flex justify-between items-end mb-6">
                    <h2 className="text-3xl font-bold text-white tracking-wide drop-shadow-[0_0_10px_rgba(168,85,247,0.5)]">DASHBOARD_V4.1</h2>
                    {scanHistory.length > 0 && (
                        <button 
                            onClick={clearHistory}
                            className="text-xs text-red-400 hover:text-red-300 flex items-center gap-2 border border-red-900/30 px-3 py-1 rounded bg-red-900/10 transition-colors hover:bg-red-900/20"
                        >
                            <Icons.Trash2 className="w-3 h-3" /> CLEAR DATA
                        </button>
                    )}
                </div>

                {scanHistory.length === 0 ? (
                <div className="flex flex-col items-center justify-center h-64 border border-dashed border-purple-900/50 rounded-xl text-gray-500 bg-purple-900/5">
                    <Icons.Activity className="w-12 h-12 mb-4 opacity-50 text-purple-500 animate-pulse" />
                    <p className="font-mono text-sm text-white">NO DEEP SCAN DATA AVAILABLE</p>
                </div>
                ) : (
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                    {scanHistory.map((scan, index) => (
                    <div key={index} className="bg-black border border-purple-900/50 p-6 rounded-xl hover:border-purple-500 transition-all duration-300 shadow-[0_0_15px_rgba(88,28,135,0.1)] hover:shadow-[0_0_25px_rgba(168,85,247,0.2)] group relative overflow-hidden">
                        <div className="absolute top-0 right-0 w-24 h-24 bg-purple-900/10 rounded-full blur-2xl pointer-events-none group-hover:bg-purple-600/10 transition-colors"></div>
                        
                        <div className="mb-4 border-b border-purple-900/30 pb-3">
                            <div className="flex items-center space-x-2 mb-2">
                                <div className="p-1.5 rounded-lg bg-purple-900/30 text-purple-400">
                                    <Icons.Fingerprint className="w-4 h-4" />
                                </div>
                                <span className="text-white font-bold font-mono text-xs tracking-wider uppercase">Structure Analysis #{scanHistory.length - index}</span>
                            </div>
                            
                            <div className="flex flex-col gap-1 mt-2">
                                <div className="flex items-center gap-2 text-[10px] font-mono text-cyan-300 truncate">
                                    <span className="bg-cyan-900/30 px-1 rounded text-cyan-500">ORIG</span>
                                    {scan.originalName}
                                </div>
                                <div className="flex items-center gap-2 text-[10px] font-mono text-red-300 truncate">
                                    <span className="bg-red-900/30 px-1 rounded text-red-500">SUSP</span>
                                    {scan.suspectName}
                                </div>
                            </div>
                        </div>

                        <div className="space-y-4">
                            <div>
                                <p className="text-purple-400 text-xs uppercase tracking-widest font-semibold mb-1">Structural Similarity</p>
                                <div className="flex items-end gap-2">
                                    <h3 className={`text-4xl font-bold font-mono leading-none ${parseFloat(scan.score) > 50 ? 'text-red-500 drop-shadow-[0_0_8px_rgba(239,68,68,0.5)]' : 'text-white'}`}>
                                        {scan.score}%
                                    </h3>
                                </div>
                            </div>
                            
                            <div className="bg-white/5 p-3 rounded-lg border border-white/10 space-y-2">
                                <div className="flex justify-between text-xs">
                                    <span className="text-gray-400">Total Tokens:</span>
                                    <span className="text-white font-mono">{scan.totalTokens}</span>
                                </div>
                                <div className="flex justify-between text-xs">
                                    <span className="text-gray-400">Matched Tokens:</span>
                                    <span className="text-green-400 font-mono font-bold">{scan.matchedTokenCount}</span>
                                </div>
                            </div>

                            {scan.renamedVars && scan.renamedVars.length > 0 && (
                                <div className="text-[10px] bg-yellow-900/20 border border-yellow-700/30 p-2 rounded">
                                    <p className="text-yellow-500 font-bold mb-1">DETECTED RENAMES:</p>
                                    {scan.renamedVars.slice(0,3).map((v, i) => (
                                        <div key={i} className="text-yellow-200/70 font-mono truncate">{v}</div>
                                    ))}
                                    {scan.renamedVars.length > 3 && <div className="text-yellow-200/50 italic">+{scan.renamedVars.length - 3} more</div>}
                                </div>
                            )}
                            
                            <div className="text-[10px] text-gray-500 text-right font-mono">
                                {scan.timestamp}
                            </div>
                        </div>
                    </div>
                    ))}
                </div>
                )}
            </div>
        );

        const ScannerView = ({ onScanComplete }) => {
            const [showPanel, setShowPanel] = useState(false);
            const [originalFile, setOriginalFile] = useState(null);
            const [suspectFile, setSuspectFile] = useState(null);
            const [originalCode, setOriginalCode] = useState("");
            const [suspectCode, setSuspectCode] = useState("");
            const [isProcessing, setIsProcessing] = useState(false);
            const [scanResult, setScanResult] = useState(null);
            const [fullscreen, setFullscreen] = useState(false);
            const [showLiveScan, setShowLiveScan] = useState(false); 

            const fileInputRef1 = useRef(null);
            const fileInputRef2 = useRef(null);

            const handleFileRead = (file, setFileState, setContentState) => {
                if (file) {
                    setFileState(file);
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        setContentState(e.target.result);
                    };
                    reader.readAsText(file);
                }
            };

            // Memoize tokens to prevent heavy re-calculation on every render
            const originalTokens = useMemo(() => tokenize(originalCode), [originalCode]);
            const suspectTokens = useMemo(() => tokenize(suspectCode), [suspectCode]);

            const startDeepScan = () => {
                setIsProcessing(true);
                // Artificial delay for UI effect + non-blocking
                const delay = showLiveScan ? 4000 : 1500; 
                
                setTimeout(() => {
                    const analysis = performDeepAnalysis(originalTokens, suspectTokens);
                    
                    const result = {
                        ...analysis,
                        originalName: originalFile.name,
                        suspectName: suspectFile.name,
                        tokens1: originalTokens,
                        tokens2: suspectTokens,
                        timestamp: new Date().toLocaleTimeString()
                    };

                    setScanResult(result);
                    onScanComplete(result);
                    setIsProcessing(false);
                    setShowPanel(false);
                }, delay);
            };

            return (
                <div className={`flex flex-col animate-fade-in relative font-tech ${fullscreen ? 'fixed inset-0 z-50 bg-black p-4' : 'h-full p-2'}`}>
                <div className="flex justify-between items-center mb-6">
                    <h2 className="text-3xl font-bold text-white tracking-wide flex items-center gap-3 drop-shadow-[0_0_15px_rgba(168,85,247,0.5)]">
                        DEEP_SCANNER <span className="text-xs bg-purple-900/50 px-2 py-0.5 rounded text-purple-300 border border-purple-500/30">V4.1 STRUCTURAL</span>
                    </h2>
                    {scanResult && (
                        <button onClick={() => setFullscreen(!fullscreen)} className="text-gray-400 hover:text-white transition-colors bg-white/5 p-2 rounded hover:bg-white/10">
                            {fullscreen ? <Icons.Minimize2 className="w-5 h-5"/> : <Icons.Maximize2 className="w-5 h-5"/>}
                        </button>
                    )}
                </div>

                {!scanResult ? (
                    <div className="flex-1 bg-black border border-purple-900/50 rounded-xl p-8 flex flex-col items-center justify-center relative overflow-hidden group shadow-[0_0_30px_rgba(88,28,135,0.1)]">
                    <div className="absolute inset-0 bg-[linear-gradient(rgba(88,28,135,0.1)_1px,transparent_1px),linear-gradient(90deg,rgba(88,28,135,0.1)_1px,transparent_1px)] bg-[size:40px_40px] opacity-20"></div>
                    
                    <div className="relative mb-8 group-hover:scale-110 transition-transform duration-500">
                        <div className="absolute inset-0 bg-purple-500/20 blur-3xl rounded-full animate-pulse"></div>
                        <Icons.Scan className="w-20 h-20 text-white relative z-10 drop-shadow-[0_0_10px_rgba(168,85,247,0.8)]" />
                    </div>
                    
                    <p className="text-white text-2xl mb-2 font-bold tracking-wide text-center">STRUCTURAL INTEGRITY SCANNER</p>
                    <p className="text-gray-400 text-sm mb-10 font-mono tracking-wide text-center max-w-md">
                        Advanced AST-like analysis. Detects copied logic even if variable names, spacing, or comments are changed.
                    </p>
                    
                    <button 
                        onClick={() => setShowPanel(true)}
                        className="relative px-12 py-4 bg-purple-600 hover:bg-white hover:text-black text-white transition-all duration-300 uppercase tracking-widest font-bold text-sm rounded-lg group-hover:shadow-[0_0_30px_rgba(168,85,247,0.6)] overflow-hidden"
                    >
                        <span className="relative z-10 flex items-center gap-2">INITIALIZE SCAN <Icons.ArrowRight className="w-4 h-4" /></span>
                    </button>
                    </div>
                ) : (
                    <div className="flex-1 flex flex-col bg-black border border-purple-900/50 rounded-xl overflow-hidden shadow-2xl">
                        <div className="p-4 border-b border-purple-900/50 flex justify-between items-center bg-purple-900/10 backdrop-blur-sm">
                            <div className="flex gap-6 text-sm font-mono">
                                <div className="flex items-center gap-2 text-red-400 font-bold bg-red-900/10 px-3 py-1 rounded border border-red-500/30">
                                    <Icons.AlertTriangle className="w-4 h-4"/> 
                                    {scanResult.renamedVars.length} DETECTED RENAMES
                                </div>
                                <div className="flex items-center gap-2 text-green-400 font-bold bg-green-900/10 px-3 py-1 rounded border border-green-500/30">
                                    <Icons.Zap className="w-4 h-4"/> 
                                    {scanResult.score}% SIMILARITY
                                </div>
                            </div>
                            <button onClick={() => setScanResult(null)} className="text-xs text-gray-300 hover:text-white flex items-center gap-1 border border-white/20 px-3 py-1.5 rounded hover:bg-white/10 transition-colors">
                                <Icons.X className="w-3 h-3" /> CLOSE REPORT
                            </button>
                        </div>

                        <div className="flex-1 flex flex-col md:flex-row overflow-hidden relative">
                            <div className="flex-1 border-b md:border-b-0 md:border-r border-purple-900/30 flex flex-col min-h-0">
                                <CodeViewer 
                                    title={`SOURCE: ${scanResult.originalName}`} 
                                    tokens={scanResult.tokens1}
                                    matchedIndices={scanResult.matchedIndices1}
                                    colorTheme="cyan"
                                />
                            </div>
                            
                            <div className="flex-1 flex flex-col min-h-0">
                                <CodeViewer 
                                    title={`SUSPECT: ${scanResult.suspectName}`}
                                    tokens={scanResult.tokens2}
                                    matchedIndices={scanResult.matchedIndices2}
                                    colorTheme="red"
                                />
                            </div>
                        </div>
                    </div>
                )}

                {showPanel && (
                    <div className="absolute inset-0 z-50 bg-black/80 backdrop-blur-md flex items-center justify-center p-4">
                        <div className={`bg-black border border-white/10 w-full ${isProcessing && showLiveScan ? 'max-w-6xl h-[80vh]' : 'max-w-lg'} rounded-2xl shadow-[0_0_60px_rgba(147,51,234,0.3)] animate-fade-in relative overflow-hidden transition-all duration-500`}>
                            <div className="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-purple-600 via-white to-purple-600"></div>
                            
                            <button 
                                onClick={() => setShowPanel(false)}
                                className="absolute top-4 right-4 text-gray-400 hover:text-white transition-colors p-1 hover:bg-white/10 rounded-full z-50"
                            >
                                <Icons.X className="w-5 h-5" />
                            </button>

                            {isProcessing && showLiveScan ? (
                                <div className="p-8 h-full flex flex-col">
                                    <h3 className="text-2xl font-bold text-white mb-4 font-tech flex items-center gap-2 animate-pulse">
                                        <Icons.Activity className="w-6 h-6 text-purple-500"/> SCANNING NEURAL PATHWAYS...
                                    </h3>
                                    <div className="flex-1 grid grid-cols-2 gap-6 min-h-0">
                                         <div className="relative border border-gray-800 rounded-lg overflow-hidden group">
                                            <div className="absolute inset-0 bg-purple-500/10 z-20 pointer-events-none"></div>
                                            <div className="scan-line z-30"></div>
                                            <CodeViewer 
                                                title="INPUT STREAM A" 
                                                tokens={originalTokens} 
                                                matchedIndices={new Set()} 
                                                colorTheme="cyan"
                                                isPreview={true}
                                            />
                                        </div>
                                         <div className="relative border border-gray-800 rounded-lg overflow-hidden group">
                                            <div className="absolute inset-0 bg-purple-500/10 z-20 pointer-events-none"></div>
                                            <div className="scan-line z-30" style={{animationDelay: '1s'}}></div>
                                            <CodeViewer 
                                                title="INPUT STREAM B" 
                                                tokens={suspectTokens} 
                                                matchedIndices={new Set()} 
                                                colorTheme="red"
                                                isPreview={true}
                                            />
                                        </div>
                                    </div>
                                    <div className="mt-4 text-center text-xs text-gray-500 font-mono">
                                        ANALYZING STRUCTURAL FINGERPRINTS...
                                    </div>
                                </div>
                            ) : (
                                <div className="p-8">
                                    <h3 className="text-2xl font-bold text-white mb-8 font-tech border-b border-white/10 pb-4 flex items-center gap-2">
                                        <Icons.Database className="w-6 h-6 text-purple-500"/> SOURCE LOADER
                                    </h3>
                                    
                                    <div className="space-y-6">
                                        <div>
                                            <label className="block text-cyan-400 text-xs font-bold mb-2 uppercase tracking-wider flex justify-between">
                                                <span>Original Source</span>
                                                <span className="text-gray-500 font-mono text-[10px]">READ ONLY</span>
                                            </label>
                                            <div 
                                                onClick={() => fileInputRef1.current.click()}
                                                className={`h-16 border-2 border-dashed rounded-xl flex items-center justify-center cursor-pointer transition-all ${originalFile ? 'border-cyan-500 bg-cyan-900/20 shadow-[0_0_15px_rgba(8,145,178,0.2)]' : 'border-gray-700 bg-white/5 hover:border-cyan-500 hover:bg-cyan-900/10'}`}
                                            >
                                                <input 
                                                    type="file" 
                                                    accept=".lua,.txt"
                                                    ref={fileInputRef1} 
                                                    className="hidden"
                                                    onChange={(e) => handleFileRead(e.target.files[0], setOriginalFile, setOriginalCode)}
                                                />
                                                {originalFile ? (
                                                    <span className="text-cyan-400 text-sm flex items-center gap-2 font-bold"><Icons.CheckCircle className="w-5 h-5" /> {originalFile.name}</span>
                                                ) : (
                                                    <span className="text-gray-400 text-sm font-mono">Select Original File</span>
                                                )}
                                            </div>
                                        </div>

                                        <div className="relative">
                                            <label className="block text-red-400 text-xs font-bold mb-2 uppercase tracking-wider flex justify-between">
                                                <span>Suspect Source</span>
                                                <span className="text-gray-500 font-mono text-[10px]">TO ANALYZE</span>
                                            </label>
                                            <div 
                                                onClick={() => fileInputRef2.current.click()}
                                                className={`h-16 border-2 border-dashed rounded-xl flex items-center justify-center cursor-pointer transition-all ${suspectFile ? 'border-red-500 bg-red-900/20 shadow-[0_0_15px_rgba(239,68,68,0.2)]' : 'border-gray-700 bg-white/5 hover:border-red-500 hover:bg-red-900/10'}`}
                                            >
                                                <input 
                                                    type="file" 
                                                    accept=".lua,.txt" 
                                                    ref={fileInputRef2}
                                                    className="hidden"
                                                    onChange={(e) => handleFileRead(e.target.files[0], setSuspectFile, setSuspectCode)}
                                                />
                                                {suspectFile ? (
                                                    <span className="text-red-400 text-sm flex items-center gap-2 font-bold"><Icons.AlertTriangle className="w-5 h-5" /> {suspectFile.name}</span>
                                                ) : (
                                                    <span className="text-gray-400 text-sm font-mono">Select Suspect File</span>
                                                )}
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div 
                                        onClick={() => setShowLiveScan(!showLiveScan)}
                                        className="mt-6 flex items-center gap-3 cursor-pointer group"
                                    >
                                        <div className={`w-5 h-5 rounded border flex items-center justify-center transition-all ${showLiveScan ? 'bg-purple-600 border-purple-600' : 'border-gray-600 bg-transparent group-hover:border-purple-500'}`}>
                                            {showLiveScan && <Icons.CheckCircle className="w-3.5 h-3.5 text-white" />}
                                        </div>
                                        <span className={`text-xs font-bold tracking-wider ${showLiveScan ? 'text-white' : 'text-gray-400 group-hover:text-gray-300'}`}>
                                            VISUALIZE SOURCE DURING SCAN
                                        </span>
                                    </div>

                                    <div className="mt-6">
                                        {originalFile && suspectFile ? (
                                            <button 
                                                onClick={startDeepScan}
                                                disabled={isProcessing}
                                                className="w-full py-4 bg-white hover:bg-gray-200 text-black font-bold uppercase tracking-widest rounded-lg transition-all flex items-center justify-center gap-3 shadow-[0_0_20px_rgba(255,255,255,0.3)] hover:shadow-[0_0_30px_rgba(255,255,255,0.5)] transform hover:-translate-y-1"
                                            >
                                                {isProcessing ? (
                                                    <span className="animate-pulse">DECODING STRUCTURE...</span>
                                                ) : (
                                                    <>EXECUTE DEEP SCAN <Icons.Zap className="w-5 h-5" /></>
                                                )}
                                            </button>
                                        ) : (
                                            <div className="w-full py-4 bg-white/5 text-gray-500 font-bold uppercase tracking-widest rounded-lg text-center cursor-not-allowed border border-white/5">
                                                Awaiting Input Stream...
                                            </div>
                                        )}
                                    </div>

                                </div>
                            )}
                        </div>
                    </div>
                )}
                </div>
            );
        };

        const App = () => {
            const [activeTab, setActiveTab] = useState('dashboard');
            
            const [scanHistory, setScanHistory] = useState(() => {
                try {
                    const saved = localStorage.getItem('eclipse_scan_history_v4');
                    return saved ? JSON.parse(saved) : [];
                } catch (e) {
                    return [];
                }
            });

            useEffect(() => {
                localStorage.setItem('eclipse_scan_history_v4', JSON.stringify(scanHistory));
            }, [scanHistory]);

            const handleScanComplete = (result) => {
                setScanHistory(prev => [result, ...prev]);
            };

            const clearHistory = () => {
                setScanHistory([]);
                localStorage.removeItem('eclipse_scan_history_v4');
            }

            return (
                <div className="flex h-screen w-full bg-black text-white selection:bg-purple-500 selection:text-white overflow-hidden font-tech">
                
                <div className="w-20 md:w-64 border-r border-purple-900/30 flex flex-col flex-shrink-0 bg-black relative z-20">
                    
                    <div className="h-24 flex items-center px-0 md:px-8 justify-center md:justify-start relative">
                        <div className="absolute inset-0 bg-purple-900/10 blur-xl"></div>
                        <Icons.Shield className="w-8 h-8 text-white relative z-10 drop-shadow-[0_0_10px_rgba(168,85,247,0.8)]" />
                        <span className="ml-4 font-bold text-2xl tracking-[0.15em] text-white hidden md:block relative z-10 font-tech">ECLIPSE</span>
                    </div>

                    <div className="h-px w-full bg-gradient-to-r from-transparent via-purple-500 to-transparent opacity-50 shadow-[0_0_10px_#a855f7]"></div>

                    <div className="flex-1 py-8 flex flex-col gap-2 px-3">
                    <p className="px-4 text-[10px] font-bold text-gray-400 uppercase tracking-[0.2em] mb-4 hidden md:block font-mono">
                        Core Systems
                    </p>

                    <button 
                        onClick={() => setActiveTab('dashboard')}
                        className={`w-full flex items-center space-x-3 px-4 py-3 rounded-lg transition-all duration-300 group border border-transparent ${
                        activeTab === 'dashboard' 
                        ? 'bg-white/10 text-white border-l-4 border-l-purple-500 shadow-[inset_0_0_20px_rgba(255,255,255,0.05)]' 
                        : 'text-gray-400 hover:text-white hover:bg-white/5'
                        }`}
                    >
                        <Icons.LayoutDashboard className={`w-5 h-5 transition-transform group-hover:scale-110 ${activeTab === 'dashboard' ? 'text-white drop-shadow-[0_0_5px_rgba(255,255,255,0.8)]' : 'text-current'}`} />
                        <span className="hidden md:block font-bold tracking-wide text-lg">Dashboard</span>
                    </button>

                    <button 
                        onClick={() => setActiveTab('scanner')}
                        className={`w-full flex items-center space-x-3 px-4 py-3 rounded-lg transition-all duration-300 group border border-transparent ${
                        activeTab === 'scanner' 
                        ? 'bg-white/10 text-white border-l-4 border-l-purple-500 shadow-[inset_0_0_20px_rgba(255,255,255,0.05)]' 
                        : 'text-gray-400 hover:text-white hover:bg-white/5'
                        }`}
                    >
                        <Icons.Scan className={`w-5 h-5 transition-transform group-hover:scale-110 ${activeTab === 'scanner' ? 'text-white drop-shadow-[0_0_5px_rgba(255,255,255,0.8)]' : 'text-current'}`} />
                        <span className="hidden md:block font-bold tracking-wide text-lg">Deep Scan</span>
                    </button>
                    </div>

                    <div className="p-6 border-t border-purple-900/30">
                    <div className="flex items-center space-x-3 opacity-70 hover:opacity-100 transition-opacity">
                        <div className="relative">
                            <div className="w-2 h-2 rounded-full bg-green-500"></div>
                            <div className="absolute inset-0 rounded-full bg-green-500 animate-ping opacity-75"></div>
                        </div>
                        <span className="text-xs text-gray-400 font-mono tracking-wider hidden md:block">V4.1 ONLINE</span>
                    </div>
                    </div>
                </div>

                <div className="flex-1 overflow-y-auto bg-black p-4 md:p-10 relative">
                    <div className="absolute top-0 right-0 w-[500px] h-[500px] bg-purple-900/10 rounded-full blur-[120px] pointer-events-none"></div>
                    <div className="absolute bottom-0 left-0 w-[300px] h-[300px] bg-white/5 rounded-full blur-[80px] pointer-events-none"></div>

                    <div className="relative z-10 max-w-7xl mx-auto h-full flex flex-col">
                        {activeTab === 'dashboard' ? (
                            <DashboardView scanHistory={scanHistory} clearHistory={clearHistory} />
                        ) : (
                            <ScannerView onScanComplete={handleScanComplete} />
                        )}
                    </div>
                </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
